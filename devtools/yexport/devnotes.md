## ymake для yexport

### Протокол общения ymake с yexport

Наивно можно сказать что все target в терминологии yexport возникают из module в терминологии ymake, но это на самом деле не так. Конструкция `SRCS(GLOBAL ...)` приводит к тому что из одной `LIBRARY` в ymake получается два target'а в yexport. Поэтому протокол взаимодействия ymake и yexport (семантический граф) отсылает семантику в виде похожем на имя функции и список её аргументов как для модулей, так и для внутримодульных макросов. С точки зрения семантического графа все такие семантические функции абсолютно равноправны и поэтому там общее пространство имён. Какие из семантических функций на стороне потребителя (yexport) будут трактоваться как таргеты в какой-то степени оставлено на усмотрение потребителей.

На этом уровне абстракции, у семантического графа есть только его producer (сам ymake) и нет выделенного потребителя. На старте работ предполагалось, что одной утилиты работы с sem-графом на все кейсы может и не хватить и сам sem-граф как протокол в котором ymake загрублённо и высокоуровнено пересказывает, что там в ya.make'ах написано должен быть стабильным и абстрактным, чтобы разные потребители могли написать свои утилиты работы с ним под себя. Даже больше: yexport после того как была придумана и реализована концепция универсального jinja генератора стал способен закрыть многие потенциально интересные варианты работы в sem-графом, но не все, и sem-граф никак не должен затачиваться адресно под нужды yexport.

Важно отметить, что сами имена "семантических функций" не явлются частью протокола sem-графа.

### Публичный интерфейс между ymake и yexport

Имена "семантических функций" которые записывает ymake в семантический граф, в идеале, нужно стандартизировать и стабилизировать, чтобы от вышеописанной идеи универсального протокола пересказа написанного в ya.make'ах можно было получать максимум возможных бенефитов (например, разные потребители с разными требованиями могли работать с одним и тем же семграфом).

Сейчас мы точно не здесь, в той же джаве какое-то количество технических деталей сейчас в семантиках путешествует.

## Работа yexport

### target и attr

В семантиках к нам пришли абсолютно равноправные сущности (сематические функции) вся иерархия между ними выражена только в виде дуг в sem-графе. При этом в целевой внешней системе сборки (или IDE проекте) мы имеем какую-то иерархию удобную для людей которые взаимодействуют с этой целевой системой сборки. Иерархия в целевой системе сборки может не совпадать с иерархией которая есть в дугах семантического графа. Поэтому yexport предлагает модель иерархии которая похожа на иерархии широкоизвестных публичных систем сборки:
- Есть корень проекта в котором могут быть заданы глобальные настройки
- Есть директории, в которых лежат файлы описания сборки и на уровне директорий могут существовать настройки общие для всех описываемых внутри сборочном файле логических сущностей.
- В файлах описания сборки есть высокоуровневые сборочные цели
- У каждой высокоуровневой сборочной цели могут быть свои уникальные свойства, которые синтаксически для каждой сборочной цели нужно уметь выписывать.
- Абстрактные сборочные цели могут зависеть друг от друга (эта часть иерархии выводится из дуг семантического графа и механизмов управления через семантические фунции этими зависимостями на самом деле нет). Для выражения таких зависимостей в целевой системе сборки нужно уметь отправлять информацию с потребляемого таргета на таргет потребитель.

В иерархии выше возникает существенная ассиметрия: всё кроме высокоуровневых целей легко описывается модулью равноправных аттрибутов. Но сами абстрактные цели группируют множество аттрибутов в себе. Вот тут и возникает то логическое разделение, в котором в generator.toml часть семантических функций опсываются не как атрибуты, а как таргеты.

Чтобы таргет можно было связать с директорией, в которой будет сгеренирован целевой сборочный файл внешней системы сборки, нужен контракт о том, что конкретный аргумент семантической функции содержит эту самую директорию. Это неявное соглашений на "Публичный интерфейс между ymake и yexport" (не на транспорт ака sem-граф, а именно на сигнатуру некоторых семантических функций). Сейчас этот неявный контракт: первый аргумент семантической функции содержит эту самую директорию.

В целевой системе сборки у того во что превращаются target'ы в терминологии yexport генератора должны быть имена и способы адресации. Какая-то базовая информация позволяющая генерировать имена и адреса тоже должна быть среди аргументов самантической функции по которой заводится target. Тут тоже появляется неявный контракт на "Публичный интерфейс между ymake и yexport" и значением по которому можно генерировать имя и адрес таргета является значение второго аргумента семантичесокой функции.
