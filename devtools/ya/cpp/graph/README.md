## Библиотека для работы с типизированным представлением сборочного графа

### intern_string.*
Простая реализация интернирования строк. Есть общее для всех строк глобальное (singleton) хранилище `TInternStringStorage`. Его задача сохранить строку ровно один раз и сгенерировать для неё уникальный индекс, чтобы в дальнейшем по этому индексу вернуть строку. Хранилище потокобезопасное. Для уменьшения коллизий оно состоит из 16 независимых партиций, каждое из которых имеет собственный mutex и структуры для хранения данных. Выбор партиции производится по длине строки (примитивное шардирование).
`TInternString` - это хендлер для прозрачного доступа к сохранённым строкам. Размер `TInternString` 4 байта. Он используется во всех структурах графа, где требуется хранение строк.
Строки в хранилище намеренно сделаны без подсчёта количества ссылок. Предполагается, что после окончания использования всех `TInternString` хранилище будет очищено целиком.

#### Производительность
Интернирование не обходится даром. Хотя оно существенно (в 4 раза минимум) уменьшает потребление памяти, но немного замедляет загрузку графа. В абсолютных цифрах это 14 и 17-18 секунд для 3-гигабайтного json (650к нод). Если учесть, что ГГ такого графа занимает не менее 10-15 минут, такой размен можно считать оправданным.

### tinymap.*
В каждом узле графа есть словари (`Kv`, `Env` и `Requirements`). В подавляющем числе случаев они, либо пустые, либо содержат малое количество элементов (от 2 до 10). Так как граф имеет от десятков до сотен тысяч узлов, то и словарей нужно создавать пропорциональное количество. Аркадийный `THashMap` расчитан под большие объёмы, и храня даже одну пару размером 8 байт, потребляет более 200 байт. Нужен был словарь, который имел бы минимальный размер не только в расчёте на каждую пару ключ-значение, но и на каждый инстанс словаря.
Под эти требования был написан минималистический словарь, который занимает от 16 байт на каждый экземпляр, не содержит метаданных для каждый пары, и единственный оверхед, который он создаёт - это резерв под добавление новых элементов.
Интерфейс сделан максимально похожим на STL-словари, только выкинуты экзотические и неподходящие по концепции методы. В основе словаря лежит неупорядоченный массив пар ключ-значение. Все операции (вставка, поиск, удаление) имеют сложность O(N). Несмотря на "ужасную" теоретическую производительность, на практике O(N) оказался даже быстрее O(1). Крайне желательно наличие noexcept move constructor у ключа и значения, тогда расширение словаря при добавлении элементов выполняется максимально быстро.
Ещё одно нестандартное решение, кроме O(N) - это отсутствие `const` у ключа. Хотелось сохранить привычный `std::pair` для хранения пар, а константный ключ ставит крест на move constructible. Это можно было бы обойти отказом от `std::pair` в пользу своего класса, но это раздувает код, не давая особых преимуществ.

### graph.*
Определения типов для хранения графа и функции для работы с ним.

Вовне граф хранится как `TIntrusivePtr`, чтобы минимизировать риск случайного копирования графа (особенно в Cython, который плохо дружит со ссылками). Манипуляции с графом предполагают копирование узлов между графами, поэтому в графе они хранятся как `TVector<TIntrusivePtr<TNode>>`, а не `TVector<TNode>`.
Остальные структуры не такие объёмные и нагруженные в плане операций, поэтому хранятся as-is.
