#! /usr/bin/env python3

# This script was generated by `ya ide clion`.
# Do not edit, your changes will be lost.

import http.server
import json
import os
import socket
import subprocess
import sys
import tempfile
import textwrap
import threading
import time
import traceback

host = '<<host>>'
remote_repo = '<<remote_repo>>'
remote_build = '<<remote_build>>'
local_repo = '<<local_repo>>'
local_build = '<<local_build>>'

ssh_opts = [
    'ssh',
    '-o', 'ConnectTimeout=5',
    '-o', 'ConnectionAttempts=3',
    '-o', 'ServerAliveInterval=5',
    '-o', 'ServerAliveCountMax=3',
    '-o', 'ForwardAgent=yes',
]


class RsyncPaths(object):
    class Item(object):
        def __init__(self):
            self.is_leaf = False
            self.contents = {}

        def __contains__(self, item):
            return item in self.contents

        def __getitem__(self, item):
            return self.contents[item]

        def __setitem__(self, key, value):
            self.contents[key] = value

    def __init__(self):
        self.root = RsyncPaths.Item()

    def add_path(self, path):
        root = self.root
        for item in path.split(os.path.sep):
            if item not in root:
                root[item] = RsyncPaths.Item()
            root = root[item]
        root.is_leaf = True

    def empty(self):
        return len(self.root.contents) == 0

    def dump(self, os, progress):
        path = []

        def do(name, root):
            path.append(name)
            path_str = '/'.join(path)
            os.write(path_str.encode('utf-8') + b'\n')
            if root.is_leaf:
                if progress:
                    sys.stderr.write('  ' + path_str.lstrip('/') + '\n')
                os.write(path_str.encode('utf-8') + b'/**\n')
            else:
                for (name, item) in root.contents.items():
                    do(name, item)
            path.pop()

        do('', self.root)


def get_free_tcp_port():
    tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp.bind(('', 0))
    addr, port = tcp.getsockname()
    tcp.close()
    return port


def ssh(cmd):
    opts = ssh_opts + [host, cmd]
    with subprocess.Popen(opts, stderr=subprocess.PIPE, stdout=subprocess.DEVNULL) as ssh:
        (_, stderr) = ssh.communicate()

        if ssh.returncode != 0:
            sys.stderr.write(
                'Error when executing command `{}` on host {}:\n{}'.format(
                    cmd, host,
                    textwrap.indent(stderr.decode(), '  ')
                )
            )

            raise RuntimeError('error when executing ssh')


def local(*opts, stdin=None):
    with subprocess.Popen(opts,
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                          stdin=stdin,
                          cwd=local_repo) as cmd:
        (stdout, stderr) = cmd.communicate()

        if cmd.returncode != 0:
            sys.stderr.write(
                'Error when executing command `{}` locally:\n{}'.format(
                    ' '.join(opts),
                    textwrap.indent(stderr.decode(), '  ')
                )
            )

            raise RuntimeError('error when executing local command')

        return stdout


def unlink_socket():
    sock = os.path.join(remote_build, 'pull.socket')
    opts = ssh_opts + [host, 'unlink {}'.format(sock)]
    subprocess.call(opts, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)


def tunnel(port):
    unlink_socket()

    sock = os.path.join(remote_build, 'pull.socket')
    target = '{}:localhost:{}'.format(sock, port)

    opts = ssh_opts + [
        '-N', '-R',
        target, host,
        '-o', 'ExitOnForwardFailure=yes',
        '-o', 'StreamLocalBindUnlink=yes',
    ]

    while True:
        with subprocess.Popen(opts, stderr=subprocess.PIPE) as ssh:
            (_, stderr) = ssh.communicate()

            if b'remote port forwarding failed' in stderr:
                unlink_socket()
            else:
                sys.stderr.write(
                    'tunnel died and will be restarted:\n{}'.format(
                        textwrap.indent(stderr.decode(), '  ')
                    )
                )
                time.sleep(1)


def server(port):
    class Handler(http.server.BaseHTTPRequestHandler):
        error_message_format = \
            'Sync server returned code %(code)s (%(message)s):\n\n%(explain)s'
        error_content_type = 'text/plain;charset=utf-8'

        def do_GET(self):
            if self.path == '/pull':
                try:
                    sync()
                except Exception:
                    sys.stderr.write(traceback.format_exc())
                    self.send_error(500, None, traceback.format_exc())
                    return
                self.send_response(200)
                self.end_headers()
            else:
                self.send_error(404, None, traceback.format_exc())

    server = http.server.HTTPServer(('', port), Handler)
    server.serve_forever()


def sync(progress=False):
    path = os.path.join(local_build, 'sync.lock')

    if os.name == 'nt':
        import msvcrt
        lock_file = lambda f: msvcrt.locking(f.fileno(), msvcrt.LK_RLCK, os.path.getsize(path))
        unlock_file = lambda f: msvcrt.locking(f.fileno(), msvcrt.LK_UNLCK, os.path.getsize(path))
    else:
        import fcntl
        lock_file = lambda f: fcntl.lockf(f, fcntl.LOCK_EX)
        unlock_file = lambda f: fcntl.lockf(f, fcntl.LOCK_UN)

    with open(path, 'w') as f:
        lock_file(f)
        try:
            do_sync(progress)
        finally:
            unlock_file(f)


def do_sync(progress):
    # 1: get current commit hash, push it to the server

    arc_info_str = local('arc', 'info', '--json')
    arc_info = json.loads(arc_info_str)
    commit = arc_info['hash']
    if progress:
        sys.stderr.write('push commit {} to the arc server\n'.format(commit))
    local('arc', 'push', commit)

    # 2: checkout this commit at the remote host

    if progress:
        sys.stderr.write('cleanup remote repository and checkout commit {}\n'.format(commit))
    remote_cmd = 'cd {remote_repo} && arc reset --hard HEAD && arc clean -dx && arc checkout -f {commit}'.format(
        remote_repo=remote_repo,
        commit=commit,
    )
    ssh(remote_cmd)

    # 3: rsync uncommitted changed files

    arc_status_str = local('arc', 'status', '--json')
    arc_status = json.loads(arc_status_str)['status']

    paths = RsyncPaths()
    for key in ['staged', 'changed', 'untracked']:
        if key in arc_status:
            for file_status in arc_status[key]:
                if 'path' in file_status:
                    paths.add_path(file_status['path'])
                if 'orig_path' in file_status:
                    paths.add_path(file_status['orig_path'])

    if paths.empty():
        if progress:
            sys.stderr.write('done, no uncommitted files to send\n')
        return
    else:
        if progress:
            sys.stderr.write('send uncommitted files to remote host:\n')

    with tempfile.TemporaryFile() as tmp:
        paths.dump(tmp, progress)
        tmp.seek(0)

        local(
            'rsync',
            '.',
            '{}:{}'.format(host, remote_repo),
            '--checksum',
            '--delete',
            '--recursive',
            '--include-from=-',
            '--exclude=*',
            stdin=tmp,
        )

    if progress:
        sys.stderr.write('done\n')


def main():
    if len(sys.argv) == 1:
        if sys.stderr.isatty():
            sys.stderr.write('\033[1;32m')
        sys.stderr.write(
            'Uploading files to remote host {}'.format(host)
        )
        if sys.stderr.isatty():
            sys.stderr.write('\033[0m')
        sys.stderr.write('\n')
        sys.stderr.flush()

        sync(True)
    elif len(sys.argv) == 2 and sys.argv[1] == 'server':
        if sys.stderr.isatty():
            sys.stderr.write('\033[1;32m')
        sys.stderr.write(
            'This server will sync changes to the remote host upon request '
            'from a build process. Leave it running in the background.'
        )
        if sys.stderr.isatty():
            sys.stderr.write('\033[0m')
        sys.stderr.write('\n')
        sys.stderr.flush()

        port = get_free_tcp_port()

        sys.stderr.write('Server is listening on port {}\n'.format(port))

        tunnel_thread = threading.Thread(target=tunnel, args=(port,), daemon=True)
        tunnel_thread.start()

        server(port)
    else:
        sys.stderr.write(
            'Usage:\n'
            '  {bin}\n'
            '    -- upload files to remote host\n'
            '  {bin} server\n'
            '    -- start sync server\n'.format(bin=sys.argv[0]))
        exit(1)


if __name__ == '__main__':
    main()
